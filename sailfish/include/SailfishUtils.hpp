#ifndef __SAILFISH_UTILS_HPP__
#define __SAILFISH_UTILS_HPP__

#include <algorithm>
#include <iostream>
#include <tuple>
#include <unordered_set>
#include <unordered_map>
#include <memory>
#include <vector>
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>

#include "tbb/atomic.h"

#include "spdlog/details/format.h"

#include "SailfishOpts.hpp"
#include "SailfishMath.hpp"

#include "LibraryFormat.hpp"
#include "ReadLibrary.hpp"
#include "TranscriptGeneMap.hpp"
#include "RapMapUtils.hpp"
#include "Eigen/Dense"

class ReadExperiment;
class LibraryFormat;

namespace sailfish{
    namespace utils {

        using std::string;
        using NameVector = std::vector<string>;
        using IndexVector = std::vector<size_t>;
        using KmerVector = std::vector<uint64_t>;
        using MateStatus = rapmap::utils::MateStatus;

        // An enum class for direction to avoid potential errors
        // with keeping everything as a bool
        enum class Direction { FORWARD = 0, REVERSE_COMPLEMENT = 1 };

        // Returns FORWARD if isFwd is true and REVERSE_COMPLEMENT otherwise
        constexpr inline Direction boolToDirection(bool isFwd) {
            return isFwd ? Direction::FORWARD : Direction::REVERSE_COMPLEMENT;
        }

        // Returns a uint64_t where the upper 32-bits
        // contain tid and the lower 32-bits contain offset
        uint64_t encode(uint64_t tid, uint64_t offset);

        // Given a uin64_t generated by encode(), return the
        // transcript id --- upper 32-bits
        uint32_t transcript(uint64_t enc);

        // Given a uin64_t generated by encode(), return the
        // offset --- lower 32-bits
        uint32_t offset(uint64_t enc);

        // for single end reads or orphans
        bool compatibleHit(LibraryFormat expected,
                           int32_t start, bool isForward, MateStatus ms);
        // for paired-end reads
        bool compatibleHit(LibraryFormat expected, LibraryFormat observed);

        // Determine the library type of paired-end reads
        LibraryFormat hitType(int32_t end1Start, bool end1Fwd, uint32_t len1,
                              int32_t end2Start, bool end2Fwd, uint32_t len2, bool canDovetail);


        LibraryFormat parseLibraryFormatStringNew(std::string& fmt);

        std::vector<ReadLibrary> extractReadLibraries(boost::program_options::parsed_options& orderedOptions);

        LibraryFormat parseLibraryFormatString(std::string& fmt);

        size_t numberOfReadsInFastaFile(const std::string& fname);

        TranscriptGeneMap transcriptGeneMapFromGTF(const std::string& fname, std::string key="gene_id");

        TranscriptGeneMap readTranscriptToGeneMap( std::ifstream &ifile );

        TranscriptGeneMap transcriptToGeneMapFromFasta( const std::string& transcriptsFile );

        /*
         * Use atomic compare-and-swap to update val to
         * val + inc (*in log-space*).  Update occurs in a loop in case other
         * threads update in the meantime.
         */
        inline void incLoopLog(tbb::atomic<double>& val, double inc) {
            double oldMass = val.load();
            double returnedMass = oldMass;
            double newMass{sailfish::math::LOG_0};
            do {
                oldMass = returnedMass;
                newMass = sailfish::math::logAdd(oldMass, inc);
                returnedMass = val.compare_and_swap(newMass, oldMass);
            } while (returnedMass != oldMass);
        }

        /**
         * Provide the above function for non-atomic variables
         * (*not* thread safe!).
         */
        inline void incLoopLog(double& val, double inc) {
            auto newMass = sailfish::math::logAdd(val, inc);
            val = newMass;
        }

        /*
         * Use atomic compare-and-swap to update val to
         * val + inc.  Update occurs in a loop in case other
         * threads update in the meantime.
         */
        inline void incLoop(tbb::atomic<double>& val, double inc) {
            double oldMass = val.load();
            double returnedMass = oldMass;
            double newMass{oldMass + inc};
            do {
                oldMass = returnedMass;
                newMass = oldMass + inc;
                returnedMass = val.compare_and_swap(newMass, oldMass);
            } while (returnedMass != oldMass);
        }

        /**
         * Provide the above function for non-atomic variables
         * (*not* thread safe!).
         */
        inline void incLoop(double& val, double inc) {
            val += inc;
        }


        void aggregateEstimatesToGeneLevel(TranscriptGeneMap& tgm, boost::filesystem::path& inputPath);

        // NOTE: Throws an invalid_argument exception of the quant or quant_bias_corrected files do
        // not exist!
        void generateGeneLevelEstimates(boost::filesystem::path& geneMapPath,
                boost::filesystem::path& estDir,
                std::string aggKey);

        enum class OrphanStatus: uint8_t { LeftOrphan = 0, RightOrphan = 1, Paired = 2 };

        void writeAbundancesFromCollapsed(const SailfishOpts& sopt,
                ReadExperiment& alnLib,
                boost::filesystem::path& fname,
                std::string headerComments="");

        template <typename AbundanceVecT>
        Eigen::VectorXd updateEffectiveLengths(
				    SailfishOpts& sfopts,
				    ReadExperiment& readExp,
                                    Eigen::VectorXd& effLensIn,
                                    AbundanceVecT& alphas);

        //double logAlignFormatProb(const LibraryFormat observed, const LibraryFormat expected, double incompatPrior);
        //std::ostream& operator<<(std::ostream& os, OrphanStatus s);
        /**
         *  Given the information about the position and strand from which a paired-end
         *  read originated, return the library format with which it is compatible.
         */
        //LibraryFormat hitType(int32_t end1Start, bool end1Fwd,
        //                      int32_t end2Start, bool end2Fwd);
        //LibraryFormat hitType(int32_t end1Start, bool end1Fwd, uint32_t len1,
        //                      int32_t end2Start, bool end2Fwd, uint32_t len2, bool canDovetail);
        /**
         *  Given the information about the position and strand from which the
         *  single-end read originated, return the library format with which it
         *  is compatible.
         */
        //LibraryFormat hitType(int32_t readStart, bool isForward);

    }
}

#endif // __SAILFISH_UTILS_HPP__
